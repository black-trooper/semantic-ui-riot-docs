{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/riot-observable/dist/observable.js","webpack:///./node_modules/riot-route/lib/index.js","webpack:///./node_modules/riot/riot.js","webpack:///./node_modules/semantic-ui-riot/dist/semantic-ui-riot.min.js","webpack:///./src/index.js","webpack:///./tags/introduction.tag"],"names":["mount","collection","start","mixin","init","on","PR","prettyPrint","toggleExample","childs","event","target","parentElement","childNodes","segments","Array","from","filter","element","classList","contains","remove","add"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA,CAAC,8BAA8B;;AAE/B;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,WAAW;AAC3B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,WAAW;AAC5B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,WAAW;AAC5B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAGA;;AAEA,CAAC,qD;;;;;;;;;;;;;;;ACpID;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uCAAuC,SAAS,EAAE;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qCAAqC,oBAAoB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,yBAAyB;AACpC,WAAW,QAAQ;AACnB;AACA;AACA,yDAAyD,mCAAmC;AAC5F,oBAAoB,uBAAuB;AAC3C,QAAQ,oBAAoB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY,oBAAoB;AAChC;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,wDAAwD,UAAU,EAAE;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtVA;AACA;AACA;AACA,UAC2B;AAC3B,CAAC,4BAA4B;;AAE7B;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uDAAuD,GAAG,GAAG;AAC7D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,KAAK,6CAA6C;AAClD;AACA,KAAK,6BAA6B;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA,KAAK,OAAO,oCAAoC;;AAEhD;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA,eAAe,oBAAoB;AACnC,UAAU,qBAAqB;AAC/B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,yBAAyB,kBAAkB,EAAE;AAC7C;AACA;AACA,sBAAsB,6BAA6B;AACnD,UAAU,6BAA6B;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B,yBAAyB,GAAG;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA,OAAO;;AAEP;;AAEA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,2DAA2D;;AAE3D;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,eAAe;AACvB,KAAK;;AAEL,gBAAgB,EAAE;;AAElB;AACA,MAAM,KAAK;AACX,MAAM,KAAK;AACX,MAAM,GAAG,GAAG;AACZ,WAAW;AACX,SAAS,GAAG;AACZ,kBAAkB,OAAO,KAAK;AAC9B;AACA,UAAU,iDAAiD;AAC3D,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA,cAAc,aAAa;AAC3B;AACA,0BAA0B,qBAAqB;AAC/C;AACA;;AAEA;AACA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C,SAAS;AACrD,6CAA6C,EAAE;AAC/C;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C,+BAA+B;AAC/B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA,kCAAkC,aAAa;;AAE/C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA,mCAAmC,WAAW,yBAAyB;;AAEvE,sCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,kBAAkB;;AAEhC;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;;AAEA;;AAEA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA,kDAAkD,qBAAqB;;AAEvE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,MAAM;AACjC,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,qDAAqD;AACzE,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kBAAkB,oBAAoB,SAAS,UAAU;AACzD;;AAEA;;AAEA;AACA,wBAAwB,aAAa;AACrC;;AAEA,KAAK;;AAEL,0BAA0B;AAC1B;AACA,cAAc,qBAAqB;AACnC;;AAEA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,WAAW;AAC3B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,WAAW,sDAAsD;AACjE;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,WAAW;AAC5B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD,6BAA6B,oBAAoB;AACjD;AACA,WAAW,OAAO,yBAAyB;AAC3C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,WAAW;AAC5B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B,uCAAuC;AACvC;;AAEA;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA,WAAW,iDAAiD;;AAE5D;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA,cAAc;AACd,gBAAgB,uBAAuB;AACvC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,WAAW;AACxB;AACA;AACA,cAAc;AACd;AACA;AACA,KAAK,8CAA8C;AACnD;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA,wBAAwB,8BAA8B,oBAAoB;AAC1E;AACA;AACA;AACA,wDAAwD;AACxD,GAAG;AACH;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,WAAW;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa,IAAI;AACjB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI;AACf,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,IAAI;AACjB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA,0EAA0E;AAC1E,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,QAAQ,SAAS,OAAO,gBAAgB;AACxC;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,CAAC;;AAED;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA,gDAAgD,wBAAwB,EAAE;AAC1E;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,gCAAgC,uBAAuB;AACvD;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA,6BAA6B,oBAAoB;AACjD,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK,OAAO,0BAA0B;AACtC;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAmD;AAChE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,GAAG;AACH;AACA;AACA,kDAAkD,2BAA2B;AAC7E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,GAAG;;AAEH;AACA,kDAAkD;AAClD;AACA,KAAK;AACL,4CAA4C;AAC5C;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,qCAAqC;AAC1C;AACA,KAAK,+BAA+B;;AAEpC;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,WAAW;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA,gCAAgC,yBAAyB;AACzD;AACA,+BAA+B,mCAAmC;;AAElE;;AAEA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,4BAA4B;AACrE,8BAA8B,2BAA2B;AACzD,mCAAmC,gEAAgE;;AAEnG;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,wCAAwC;;AAE7C;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD,2BAA2B,iBAAiB;AAC5C,qDAAqD,wBAAwB;AAC7E,GAAG;AACH,KAAK,iBAAiB,EAAE;AACxB;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA,KAAK,wCAAwC;AAC7C;AACA,KAAK,uBAAuB;AAC5B;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,iCAAiC,gDAAgD,EAAE;AACnF;AACA;;AAEA;AACA,kBAAkB,0CAA0C;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB;AACA,4CAA4C,gDAAgD;AAC5F;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;AAEpB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kCAAkC;AACpD,oBAAoB;AACpB,mDAAmD;;AAEnD;AACA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA,kBAAkB,YAAY;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B,uBAAuB,EAAE;AACnD,OAAO;AACP,YAAY,uBAAuB;AACnC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,MAAM;AACnB,aAAa,UAAU;AACvB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,IAAI;AACf,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,wBAAwB;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,6BAA6B;AAChD;AACA,mBAAmB,wBAAwB;;AAE3C;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,0BAA0B,EAAE;AACtD;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,uBAAuB;;AAEnC;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,WAAW;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,OAAO,YAAY;AACnB;;AAEA;AACA;AACA,OAAO,UAAU;AACjB;AACA,OAAO,uBAAuB;AAC9B;;AAEA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,WAAW;AACxB,aAAa,SAAS;AACtB;AACA;AACA,YAAY,6BAA6B;;AAEzC,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,gBAAgB;AACzB,KAAK;AACL,OAAO,wBAAwB,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iBAAiB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,0BAA0B;AACjC;AACA;AACA;;AAEA,iCAAiC,wCAAwC,EAAE;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C,4BAA4B;AAC5B;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,4CAA4C,qBAAqB,EAAE;AACnE;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK,OAAO,gBAAgB;;AAE5B;;AAEA;AACA,QAAQ,mEAAmE;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,OAAO,yCAAyC;AAChD,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;;AAEA;AACA,KAAK,+DAA+D;AACpE,QAAQ,yCAAyC;AACjD;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,IAAI;AACjB,aAAa,IAAI;AACjB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA,KAAK,0CAA0C;AAC/C;AACA,KAAK,2CAA2C;AAChD;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA,KAAK,0CAA0C;AAC/C;AACA,KAAK,2CAA2C;AAChD;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,UAAU;AACvB;AACA;AACA;AACA,KAAK,8BAA8B;AACnC;AACA,KAAK,6BAA6B;AAClC;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,IAAI;AACjB,aAAa,SAAS,gDAAgD;AACtE,aAAa,UAAU;AACvB,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,6CAA6C;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA,+CAA+C,sCAAsC,EAAE;AACvF,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,WAAW,8CAA8C;AACzD;AACA,WAAW,+CAA+C;;AAE1D,0BAA0B,6BAA6B;AACvD;AACA,oBAAoB,8CAA8C;AAClE,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;;AAE1C;AACA;AACA,iCAAiC,6BAA6B;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA,wBAAwB,kBAAkB;AAC1C,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,aAAa,EAAE;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC,kDAAkD;AAC1F;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,0BAA0B,2BAA2B;AACrD,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO,yDAAyD;AAChE;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,4BAA4B,wBAAwB;AACpD,4BAA4B,gBAAgB;AAC5C,GAAG;AACH;;AAEA;AACA;AACA;AACA,kBAAkB,oEAAoE;AACtF;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,KAAK,wCAAwC;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,yCAAyC;AAC9D,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C;;AAE3C;AACA;AACA,OAAO,mBAAmB,8BAA8B,EAAE;;AAE1D,qBAAqB;;AAErB;;AAEA;AACA;AACA,qBAAqB,wCAAwC,EAAE;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,mCAAmC,EAAE;AACjF;AACA,SAAS,YAAY,uBAAuB;AAC5C;;AAEA;AACA,qBAAqB;AACrB;AACA,WAAW,0IAA0I;AACrJ;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,0BAA0B;AACrC;AACA;;AAEA,8BAA8B;AAC9B,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,QAAQ;AACrB,aAAa,WAAW;AACxB;AACA;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,cAAc;AACd;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,yDAAyD,mBAAmB;AAC5E;AACA;AACA,GAAG;;AAEH;AACA,iDAAiD,oBAAoB,kBAAkB,EAAE,EAAE;AAC3F;AACA,eAAe,wBAAwB;AACvC,UAAU,2CAA2C;AACrD,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,+BAA+B;;AAElD,0BAA0B,gCAAgC;;AAE1D;AACA,4EAA4E,4BAA4B,EAAE;;AAE1G;;AAEA;AACA,4BAA4B,kCAAkC;AAC9D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,+BAA+B;;AAEzD;AACA;AACA;AACA,OAAO,wCAAwC;;AAE/C;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,wBAAwB,kCAAkC;;AAE1D;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,8DAA8D,EAAE;AACrG,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD,KAAK;AACL;;AAEA;AACA;AACA,mCAAmC,qDAAqD,EAAE;;AAE1F;AACA,qBAAqB,wBAAwB;AAC7C;AACA,eAAe,qBAAqB;;AAEpC;AACA,qBAAqB,gBAAgB;;AAErC;AACA;AACA;AACA,uBAAuB,+BAA+B;;AAEtD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA,+BAA+B,yBAAyB;;AAExD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,iCAAiC;AACjC;AACA,eAAe,aAAa;AAC5B;AACA;AACA,wBAAwB;AACxB,wBAAwB;;AAExB;AACA;AACA,GAAG;AACH,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA,yCAAyC,gDAAgD,EAAE;AAC3F;AACA;AACA;;AAEA;AACA,GAAG;AACH,oCAAoC,oDAAoD,EAAE;AAC1F,kDAAkD,mDAAmD,EAAE;;AAEvG;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA,qBAAqB,2CAA2C,GAAG,oCAAoC;AACvG;;AAEA,qBAAqB,wCAAwC;;AAE7D;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n",";(function(window, undefined) {var observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {}\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          (callbacks[event] = callbacks[event] || []).push(fn)\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) callbacks = {}\n        else {\n          if (fn) {\n            var arr = callbacks[event]\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) arr.splice(i--, 1)\n            }\n          } else delete callbacks[event]\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on)\n          fn.apply(el, arguments)\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments[i + 1] // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0)\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args)\n        }\n\n        if (callbacks['*'] && event != '*')\n          el.trigger.apply(el, ['*', event].concat(args))\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  })\n\n  return el\n\n}\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = observable\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return observable })\n  else\n    window.observable = observable\n\n})(typeof window != 'undefined' ? window : undefined);","import observable from 'riot-observable';\n\nvar RE_ORIGIN = /^.+?\\/\\/+[^/]+/,\n  EVENT_LISTENER = 'EventListener',\n  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,\n  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,\n  HAS_ATTRIBUTE = 'hasAttribute',\n  POPSTATE = 'popstate',\n  HASHCHANGE = 'hashchange',\n  TRIGGER = 'trigger',\n  MAX_EMIT_STACK_LEVEL = 3,\n  win = typeof window != 'undefined' && window,\n  doc = typeof document != 'undefined' && document,\n  hist = win && history,\n  loc = win && (hist.location || win.location), // see html5-history-api\n  prot = Router.prototype, // to minify more\n  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',\n  central = observable();;;;;;;;;;;;;;;;\n\nvar\n  started = false,\n  routeFound = false,\n  debouncedEmit,\n  base,\n  current,\n  parser,\n  secondParser,\n  emitStack = [],\n  emitStackLevel = 0;;;;;;;;;\n\n/**\n * Default parser. You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_PARSER(path) {\n  return path.split(/[/?#]/)\n}\n\n/**\n * Default parser (second). You can replace it via router.parser method.\n * @param {string} path - current path (normalized)\n * @param {string} filter - filter string (normalized)\n * @returns {array} array\n */\nfunction DEFAULT_SECOND_PARSER(path, filter) {\n  var f = filter\n    .replace(/\\?/g, '\\\\?')\n    .replace(/\\*/g, '([^/?#]+?)')\n    .replace(/\\.\\./, '.*');\n  var re = new RegExp((\"^\" + f + \"$\"));\n  var args = path.match(re);\n\n  if (args) { return args.slice(1) }\n}\n\n/**\n * Simple/cheap debounce implementation\n * @param   {function} fn - callback\n * @param   {number} delay - delay in seconds\n * @returns {function} debounced function\n */\nfunction debounce(fn, delay) {\n  var t;\n  return function () {\n    clearTimeout(t);\n    t = setTimeout(fn, delay);\n  }\n}\n\n/**\n * Set the window listeners to trigger the routes\n * @param {boolean} autoExec - see route.start\n */\nfunction start(autoExec) {\n  debouncedEmit = debounce(emit, 1);\n  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit);\n  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n  doc[ADD_EVENT_LISTENER](clickEvent, click);\n  if (autoExec) { emit(true); }\n}\n\n/**\n * Router class\n */\nfunction Router() {\n  this.$ = [];\n  observable(this); // make it observable\n  central.on('stop', this.s.bind(this));\n  central.on('emit', this.e.bind(this));\n}\n\nfunction normalize(path) {\n  return path.replace(/^\\/|\\/$/, '')\n}\n\nfunction isString(str) {\n  return typeof str == 'string'\n}\n\n/**\n * Get the part after domain name\n * @param {string} href - fullpath\n * @returns {string} path from root\n */\nfunction getPathFromRoot(href) {\n  return (href || loc.href).replace(RE_ORIGIN, '')\n}\n\n/**\n * Get the part after base\n * @param {string} href - fullpath\n * @returns {string} path from base\n */\nfunction getPathFromBase(href) {\n  return base[0] === '#'\n    ? (href || loc.href || '').split(base)[1] || ''\n    : (loc ? getPathFromRoot(href) : href || '').replace(base, '')\n}\n\nfunction emit(force) {\n  // the stack is needed for redirections\n  var isRoot = emitStackLevel === 0;\n  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) { return }\n\n  emitStackLevel++;\n  emitStack.push(function() {\n    var path = getPathFromBase();\n    if (force || path !== current) {\n      central[TRIGGER]('emit', path);\n      current = path;\n    }\n  });\n  if (isRoot) {\n    var first;\n    while (first = emitStack.shift()) { first(); } // stack increses within this call\n    emitStackLevel = 0;\n  }\n}\n\nfunction click(e) {\n  if (\n    e.which !== 1 // not left click\n    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys\n    || e.defaultPrevented // or default prevented\n  ) { return }\n\n  var el = e.target;\n  while (el && el.nodeName !== 'A') { el = el.parentNode; }\n\n  if (\n    !el || el.nodeName !== 'A' // not A tag\n    || el[HAS_ATTRIBUTE]('download') // has download attr\n    || !el[HAS_ATTRIBUTE]('href') // has no href attr\n    || el.target && el.target !== '_self' // another window or frame\n    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) === -1 // cross origin\n  ) { return }\n\n  if (el.href !== loc.href\n    && (\n      el.href.split('#')[0] === loc.href.split('#')[0] // internal jump\n      || base[0] !== '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base\n      || base[0] === '#' && el.href.split(base)[0] !== loc.href.split(base)[0] // outside of #base\n      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found\n    )) { return }\n\n  e.preventDefault();\n}\n\n/**\n * Go to the path\n * @param {string} path - destination path\n * @param {string} title - page title\n * @param {boolean} shouldReplace - use replaceState or pushState\n * @returns {boolean} - route not found flag\n */\nfunction go(path, title, shouldReplace) {\n  // Server-side usage: directly execute handlers for the path\n  if (!hist) { return central[TRIGGER]('emit', getPathFromBase(path)) }\n\n  path = base + normalize(path);\n  title = title || doc.title;\n  // browsers ignores the second parameter `title`\n  shouldReplace\n    ? hist.replaceState(null, title, path)\n    : hist.pushState(null, title, path);\n  // so we need to set it manually\n  doc.title = title;\n  routeFound = false;\n  emit();\n  return routeFound\n}\n\n/**\n * Go to path or set action\n * a single string:                go there\n * two strings:                    go there with setting a title\n * two strings and boolean:        replace history with setting a title\n * a single function:              set an action on the default route\n * a string/RegExp and a function: set an action on the route\n * @param {(string|function)} first - path / action / filter\n * @param {(string|RegExp|function)} second - title / action\n * @param {boolean} third - replace flag\n */\nprot.m = function(first, second, third) {\n  if (isString(first) && (!second || isString(second))) { go(first, second, third || false); }\n  else if (second) { this.r(first, second); }\n  else { this.r('@', first); }\n};\n\n/**\n * Stop routing\n */\nprot.s = function() {\n  this.off('*');\n  this.$ = [];\n};\n\n/**\n * Emit\n * @param {string} path - path\n */\nprot.e = function(path) {\n  this.$.concat('@').some(function(filter) {\n    var args = (filter === '@' ? parser : secondParser)(normalize(path), normalize(filter));\n    if (typeof args != 'undefined') {\n      this[TRIGGER].apply(null, [filter].concat(args));\n      return routeFound = true // exit from loop\n    }\n  }, this);\n};\n\n/**\n * Register route\n * @param {string} filter - filter for matching to url\n * @param {function} action - action to register\n */\nprot.r = function(filter, action) {\n  if (filter !== '@') {\n    filter = '/' + normalize(filter);\n    this.$.push(filter);\n  }\n  this.on(filter, action);\n};\n\nvar mainRouter = new Router();\nvar route = mainRouter.m.bind(mainRouter);\n\n/**\n * Create a sub router\n * @returns {function} the method of a new Router object\n */\nroute.create = function() {\n  var newSubRouter = new Router();\n  // assign sub-router's main method\n  var router = newSubRouter.m.bind(newSubRouter);\n  // stop only this sub-router\n  router.stop = newSubRouter.s.bind(newSubRouter);\n  return router\n};\n\n/**\n * Set the base of url\n * @param {(str|RegExp)} arg - a new base or '#' or '#!'\n */\nroute.base = function(arg) {\n  base = arg || '#';\n  current = getPathFromBase(); // recalculate current path\n};\n\n/** Exec routing right now **/\nroute.exec = function() {\n  emit(true);\n};\n\n/**\n * Replace the default router to yours\n * @param {function} fn - your parser function\n * @param {function} fn2 - your secondParser function\n */\nroute.parser = function(fn, fn2) {\n  if (!fn && !fn2) {\n    // reset parser for testing...\n    parser = DEFAULT_PARSER;\n    secondParser = DEFAULT_SECOND_PARSER;\n  }\n  if (fn) { parser = fn; }\n  if (fn2) { secondParser = fn2; }\n};\n\n/**\n * Helper function to get url query as an object\n * @returns {object} parsed query\n */\nroute.query = function() {\n  var q = {};\n  var href = loc.href || current;\n  href.replace(/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v; });\n  return q\n};\n\n/** Stop routing **/\nroute.stop = function () {\n  if (started) {\n    if (win) {\n      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit);\n      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit);\n      doc[REMOVE_EVENT_LISTENER](clickEvent, click);\n    }\n    central[TRIGGER]('stop');\n    started = false;\n  }\n};\n\n/**\n * Start routing\n * @param {boolean} autoExec - automatically exec after starting if true\n */\nroute.start = function (autoExec) {\n  if (!started) {\n    if (win) {\n      if (document.readyState === 'interactive' || document.readyState === 'complete') {\n        start(autoExec);\n      }\n      else {\n        document.onreadystatechange = function () {\n          if (document.readyState === 'interactive') {\n            // the timeout is needed to solve\n            // a weird safari bug https://github.com/riot/route/issues/33\n            setTimeout(function() { start(autoExec); }, 1);\n          }\n        };\n      }\n    }\n    started = true;\n  }\n};\n\n/** Prepare the router **/\nroute.base();\nroute.parser();\n\nexport default route;\n","/* Riot v3.9.0, @license MIT */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\nvar\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n  // tags instances cache\n  __TAGS_CACHE = [],\n  // tags implementation cache\n  __TAG_IMPL = {},\n  YIELD_TAG = 'yield',\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes or attributes\n  ATTRS_PREFIX = 'riot-',\n\n  // Riot Directives\n  REF_DIRECTIVES = ['ref', 'data-ref'],\n  IS_DIRECTIVE = 'data-is',\n  CONDITIONAL_DIRECTIVE = 'if',\n  LOOP_DIRECTIVE = 'each',\n  LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n  SHOW_DIRECTIVE = 'show',\n  HIDE_DIRECTIVE = 'hide',\n  KEY_DIRECTIVE = 'key',\n  RIOT_EVENTS_KEY = '__riot-events__',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n\n  XLINK_NS = 'http://www.w3.org/1999/xlink',\n  SVG_NS = 'http://www.w3.org/2000/svg',\n  XLINK_REGEX = /^xlink:(\\w+)/,\n\n  WIN = typeof window === T_UNDEF ? undefined : window,\n\n  // special native tags that cannot be treated like the others\n  RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n  RE_EVENTS_PREFIX = /^on/,\n  RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n  // some DOM attributes must be normalized\n  CASE_SENSITIVE_ATTRIBUTES = {\n    'viewbox': 'viewBox',\n    'preserveaspectratio': 'preserveAspectRatio'\n  },\n  /**\n   * Matches boolean HTML attributes in the riot tag definition.\n   * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n   * @const {RegExp}\n   * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n   */\n  RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction makeElement(name) {\n  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttribute(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\nvar styleNode;\n// Create cache and shortcut to the correct property\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = ((function () {\n    // create a new style element with the correct type\n    var newNode = makeElement('style');\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n\n    setAttribute(newNode, 'type', 'text/css');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    } else { document.head.appendChild(newNode); }\n\n    return newNode\n  }))();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function (k) { return byName[k]; })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n}\n\n/**\n * The riot template engine\n * @version v3.0.8\n */\n\nvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n  var beforeReWords = [\n    'case',\n    'default',\n    'do',\n    'else',\n    'in',\n    'instanceof',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield'\n  ];\n\n  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n    return s + w.slice(-1)\n  }, '');\n\n  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n  var RE_VN_CHAR = /[$\\w]/;\n\n  function prev (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])){ }\n    return pos\n  }\n\n  function _skipRegex (code, start) {\n\n    var re = /.*/g;\n    var pos = re.lastIndex = start++;\n    var match = re.exec(code)[0].match(RE_REGEX);\n\n    if (match) {\n      var next = pos + match[0].length;\n\n      pos = prev(code, pos);\n      var c = code[pos];\n\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      if (c === '.') {\n\n        if (code[pos - 1] === '.') {\n          start = next;\n        }\n\n      } else if (c === '+' || c === '-') {\n\n        if (code[--pos] !== c ||\n            (pos = prev(code, pos)) < 0 ||\n            !RE_VN_CHAR.test(code[pos])) {\n          start = next;\n        }\n\n      } else if (~wordsLastChar.indexOf(c)) {\n\n        var end = pos + 1;\n\n        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){ }\n        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n          start = next;\n        }\n      }\n    }\n\n    return start\n  }\n\n  return _skipRegex\n\n})();\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n    },\n\n    DEFAULT = '{ }';;;;;;;;;\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;;;;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];;;;;;\n\n    var qblocks = [];\n    var prevStr = '';\n    var mark, lastIndex;;\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      lastIndex = re.lastIndex;\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n\n          var ch = match[2];\n          var rech = FINDBRACES[ch];\n          var ix = 1;\n\n          rech.lastIndex = lastIndex;\n          while ((match = rech.exec(str))) {\n            if (match[1]) {\n              if (match[1] === ch) { ++ix; }\n              else if (!--ix) { break }\n            } else {\n              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n            }\n          }\n          re.lastIndex = ix ? str.length : rech.lastIndex;\n          continue\n        }\n\n        if (!match[3]) {\n          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    parts.qblocks = qblocks;\n\n    return parts\n\n    function unescapeStr (s) {\n      if (prevStr) {\n        s = prevStr + s;\n        prevStr = '';\n      }\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n      if (slash) {\n        _lastIndex = skipRegex(str, _pos);\n      }\n\n      if (tmpl && _lastIndex > _pos + 2) {\n        mark = '\\u2057' + qblocks.length + '~';\n        qblocks.push(str.slice(_pos, _lastIndex));\n        prevStr += str.slice(start, _pos) + mark;\n        start = _lastIndex;\n      }\n      return _lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n  _brackets.skipRegex = skipRegex;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(\n      data, _logErr.bind({\n        data: data,\n        tmpl: str\n      })\n    )\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      console.error(err.message);\n      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n      console.log(this.data); // eslint-disable-line\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var RE_DQUOTE = /\\u2057/g;\n  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n    var qstr = parts.qblocks;\n    var expr;\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];;;\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr.length) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n      .replace(/\\s+/g, ' ').trim()\n      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;;;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;;;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];;;\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;;;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.8';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;;;;;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Short alias for Object.getOwnPropertyDescriptor\n */\nfunction getPropDescriptor (o, k) {\n  return Object.getOwnPropertyDescriptor(o, k)\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } true if writable\n */\nfunction isWritable(obj, key) {\n  var descriptor = getPropDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj;\n  var i = 1;\n  var args = arguments;\n  var l = args.length;\n\n  for (; i < l; i++) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Alias for Object.create\n */\nfunction create(src) {\n  return Object.create(src)\n}\n\nvar settings = extend(create(brackets.settings), {\n  skipAnonymousTags: true,\n  // handle the auto updates on any DOM event\n  autoUpdate: true\n})\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return [].slice.call((ctx || document).querySelectorAll(selector))\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom.hidden = show ? false : true;\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttribute(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction removeAttribute(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n * @param { Boolean } isSvg - svg tags should be treated a bit differently\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html, isSvg) {\n  // innerHTML is not supported on svg tags so we neet to treat them differently\n  if (isSvg) {\n    var node = container.ownerDocument.importNode(\n      new DOMParser()\n        .parseFromString((\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\"), 'application/xml')\n        .documentElement,\n      true\n    );\n\n    container.appendChild(node);\n  } else {\n    container.innerHTML = html;\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  if (!html) { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFragment() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\n\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: makeElement,\n\tsetAttr: setAttribute,\n\ttoggleVisibility: toggleVisibility,\n\tgetAttr: getAttribute,\n\tremAttr: removeAttribute,\n\tsetInnerHTML: setInnerHTML,\n\twalkAttrs: walkAttributes,\n\tcreateFrag: createFragment,\n\tsafeInsert: safeInsert,\n\tstyleObjectToString: styleObjectToString,\n\twalkNodes: walkNodes\n});\n\n/**\n * Check against the null and undefined values\n * @param   { * }  value -\n * @returns {Boolean} -\n */\nfunction isNil(value) {\n  return isUndefined(value) || value === null\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isNil(value) || value === ''\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if a DOM node is an svg tag or part of an svg\n * @param   { HTMLElement }  el - node we want to test\n * @returns {Boolean} true if it's an svg node\n */\nfunction isSvg(el) {\n  var owner = el.ownerSVGElement;\n  return !!owner || owner === null\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check if the passed argument is a boolean attribute\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n\n\nvar check = Object.freeze({\n\tisBlank: isBlank,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisSvg: isSvg,\n\tisWritable: isWritable,\n\tisArray: isArray,\n\tisBoolAttr: isBoolAttr,\n\tisNil: isNil,\n\tisString: isString,\n\tisUndefined: isUndefined\n});\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; i++) { fn(list[i], i); }\n  return list\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Function returning always a unique identifier\n * @returns { Number } - number from 0...n\n */\nvar uid = (function uid() {\n  var i = -1;\n  return function () { return ++i; }\n})()\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction define(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Warn a message via console\n * @param   {String} message - warning message\n */\nfunction warn(message) {\n  if (console && console.warn) { console.warn(message); }\n}\n\n\n\nvar misc = Object.freeze({\n\tcontains: contains,\n\teach: each,\n\tgetPropDescriptor: getPropDescriptor,\n\tstartsWith: startsWith,\n\tuid: uid,\n\tdefineProperty: define,\n\tobjectCreate: create,\n\textend: extend,\n\ttoCamel: toCamel,\n\twarn: warn\n});\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction get(dom) {\n  return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) ||\n    getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getName(dom, skipDataIs) {\n  var child = get(dom);\n  var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n    namedTag : child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * Return a temporary context containing also the parent properties\n * @this Tag\n * @param { Tag } - temporary tag context containing all the parent properties\n */\nfunction inheritParentProps() {\n  if (this.parent) { return extend(create(this), this.parent) }\n  return this\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar\n  reHasYield  = /<yield\\b/i,\n  reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n  reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n  reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n  rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n  tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n  GENERIC = 'div',\n  SVG = 'svg';;;;;;;;\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';;\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } isSvg - true if the root node is an svg\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, isSvg) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n  var  tagName = match && match[1].toLowerCase();\n  var el = makeElement(isSvg ? SVG : GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl, isSvg); }\n\n  return el\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParent(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent;\n  var item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  // avoid auto updates\n  if (!settings.autoUpdate) { return }\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParent(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName;\n  var cb = handleEvent.bind(tag, dom, handler);\n\n  // avoid to bind twice the same event\n  // possible fix for #2332\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChild(child, opts, innerHTML, parent) {\n  var tag = createTag(child, opts, innerHTML);\n  var tagName = opts.tagName || getName(opts.root, true);\n  var ptag = getImmediateCustomParent(parent);\n  // fix for the parent attribute in the looped elements\n  define(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  return tag\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else if (obj[key] === value)\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder();\n  var tail = createDOMPlaceholder();\n  var frag = createFragment();\n  var sib;\n  var el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFragment();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var tag = expr.tag || expr.dom._tag;\n  var ref;\n\n  var ref$1 = tag ? tag.__ : {};\n  var head = ref$1.head;\n  var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n  if (tag && expr.tagName === tagName) {\n    tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    tag.unmount(true);\n  }\n\n  // unable to get the tag name\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n\n  // unknown implementation\n  if (!expr.impl) { return }\n\n  expr.tag = tag = initChild(\n    expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    },\n    expr.dom.innerHTML,\n    parent\n  );\n\n  each(expr.attrs, function (a) { return setAttribute(tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  tag.mount();\n\n  // root exist first time, after use placeholder\n  if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function () {\n    var delName = tag.opts.dataIs;\n    arrayishRemove(tag.parent.tags, delName, tag);\n    arrayishRemove(tag.__.parent.tags, delName, tag);\n    tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttribute(this.root,'virtualized')) { return }\n\n  var dom = expr.dom;\n  // remove the riot- prefix\n  var attrName = normalizeAttrName(expr.attr);\n  var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n  var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n  var ref = this.__;\n  var isAnonymous = ref.isAnonymous;\n  var parent = dom && (expr.parent || dom.parentNode);\n  // detect the style attributes\n  var isStyleAttr = attrName === 'style';\n  var isClassAttr = attrName === 'class';\n\n  var value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.__.wasCreated) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n  // ...it seems to be a simple expression so we try to calculate its value\n  value = tmpl(expr.expr, context);\n\n  var hasValue = !isBlank(value);\n  var isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n    // remove either riot-* attributes or just the attribute name\n    removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n  if (isObj && !isClassAttr && !isStyleAttr && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (!hasValue) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    } else if (hasValue && value !== false) {\n      setAttribute(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction update(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n  var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateExpression.call(ctx, attr.expr); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n/**\n * Update the tag expressions and options\n * @param { Tag } tag - tag object\n * @param { * } data - data we want to use to extend the tag properties\n * @param { Array } expressions - component expressions array\n * @returns { Tag } the current tag instance\n */\nfunction componentUpdate(tag, data, expressions) {\n  var __ = tag.__;\n  var nextOpts = {};\n  var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n  // inherit properties from the parent tag\n  if (__.isAnonymous && __.parent) { extend(tag, __.parent); }\n  extend(tag, data);\n\n  updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n  if (\n    canTrigger &&\n    tag.isMounted &&\n    isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)\n  ) {\n    return tag\n  }\n\n  extend(tag.opts, nextOpts);\n\n  if (canTrigger) { tag.trigger('update', data); }\n  update.call(tag, expressions);\n  if (canTrigger) { tag.trigger('updated'); }\n\n  return tag\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction query(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + query(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mount$1(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount(selector, tagName, opts) {\n  var tags = [];\n  var elem, allTags;;\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttribute(root, IS_DIRECTIVE), tag;;\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttribute(root, IS_DIRECTIVE, tagName);\n      }\n\n      tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = query() :\n      // or just the ones named like the selector\n      selector + query(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || query();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin((\"__\" + (mixins_id++) + \"__\"), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error((\"Unregistered mixin: \" + name)) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister(name) {\n  __TAG_IMPL[name] = null;\n}\n\nvar version = 'v3.9.0';\n\n\nvar core = Object.freeze({\n\tTag: Tag,\n\ttag: tag,\n\ttag2: tag2,\n\tmount: mount,\n\tmixin: mixin,\n\tupdate: update$1,\n\tunregister: unregister,\n\tversion: version\n});\n\n/**\n * Add a mixin to this tag\n * @returns { Tag } the current tag instance\n */\nfunction componentMixin(tag$$1) {\n  var mixins = [], len = arguments.length - 1;\n  while ( len-- > 0 ) mixins[ len ] = arguments[ len + 1 ];\n\n  each(mixins, function (mix) {\n    var instance;\n    var obj;\n    var props = [];\n\n    // properties blacklisted and will not be bound to the tag instance\n    var propsBlacklist = ['init', '__proto__'];\n\n    mix = isString(mix) ? mixin(mix) : mix;\n\n    // check if the mixin is a function\n    if (isFunction(mix)) {\n      // create the new mixin instance\n      instance = new mix();\n    } else { instance = mix; }\n\n    var proto = Object.getPrototypeOf(instance);\n\n    // build multilevel prototype inheritance chain property list\n    do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n    while (obj = Object.getPrototypeOf(obj || instance))\n\n    // loop the keys in the function prototype or the all object keys\n    each(props, function (key) {\n      // bind methods to tag\n      // allow mixins to override other properties/parent mixins\n      if (!contains(propsBlacklist, key)) {\n        // check for getters/setters\n        var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n        var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n        // apply method only if it does not already exist on the instance\n        if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n          Object.defineProperty(tag$$1, key, descriptor);\n        } else {\n          tag$$1[key] = isFunction(instance[key]) ?\n            instance[key].bind(tag$$1) :\n            instance[key];\n        }\n      }\n    });\n\n    // init method will be called automatically\n    if (instance.init)\n      { instance.init.bind(tag$$1)(tag$$1.opts); }\n  });\n\n  return tag$$1\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChild(tagName, newPos) {\n  var parent = this.parent;\n  var tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head;\n  var sib;\n  var frag = createFragment();\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length;\n  var j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChild.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Return the value we want to use to lookup the postion of our items in the collection\n * @param   { String }  keyAttr         - lookup string or expression\n * @param   { * }       originalItem    - original item from the collection\n * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n * @returns { * } value that we will use to figure out the item position via collection.indexOf\n */\nfunction getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n  if (keyAttr) {\n    return hasKeyAttrExpr ?  tmpl(keyAttr, keyedItem) :  originalItem[keyAttr]\n  }\n\n  return originalItem\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n  var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n  var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n  var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n  var tagName = getName(dom);\n  var impl = __TAG_IMPL[tagName];\n  var parentNode = dom.parentNode;\n  var placeholder = createDOMPlaceholder();\n  var child = get(dom);\n  var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n  var tags = [];\n  var isLoop = true;\n  var innerHTML = dom.innerHTML;\n  var isAnonymous = !__TAG_IMPL[tagName];\n  var isVirtual = dom.tagName === 'VIRTUAL';\n  var oldItems = [];\n  var hasKeys;\n\n  // remove the each property from the original tag\n  removeAttribute(dom, LOOP_DIRECTIVE);\n  removeAttribute(dom, KEY_DIRECTIVE);\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { removeAttribute(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var items = expr.value;\n    var frag = createFragment();\n    var isObject = !isArray(items) && !isString(items);\n    var root = placeholder.parentNode;\n    var tmpItems = [];\n\n    // if this DOM was removed the update here is useless\n    // this condition fixes also a weird async issue on IE in our unit test\n    if (!root) { return }\n\n    // object loop. any changes cause full redraw\n    if (isObject) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function (item, i) {\n        if (expr.key && !isObject)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function (_item, i) {\n      var item = !hasKeys && expr.key ? mkitem(expr, _item, i) : _item;\n      var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n      // reorder only if the items are objects\n      var doReorder = mustReorder && typeof _item === T_OBJECT && !hasKeys;\n      var oldPos = oldItems.indexOf(itemId);\n      var isNew = oldPos === -1;\n      var pos = !isNew && doReorder ? oldPos : i;\n      // does a tag exist in this position?\n      var tag = tags[pos];\n      var mustAppend = i >= oldItems.length;\n      var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      // new tag\n      if (mustCreate) {\n        tag = createTag(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (keyAttr || contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      extend(tag.__, {\n        item: item,\n        index: i,\n        parent: parent\n      });\n\n      tmpItems[i] = itemId;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = tmpItems.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function () {\n    each(tags, function (t) { t.unmount(); });\n  };\n\n  return expr\n}\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParent(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n    if (!isBlank(this.value) && isString(this.value)) {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n\n      if (this.value !== old) {\n        setAttribute(this.dom, this.attr, this.value);\n      }\n    } else {\n      removeAttribute(this.dom, this.attr);\n    }\n\n    // cache the ref bound to this dom node\n    // to reuse it in future (see also #2329)\n    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParent(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n  }\n}\n\n/**\n * Create a new ref directive\n * @param   { HTMLElement } dom - dom node having the ref attribute\n * @param   { Tag } context - tag instance where the DOM node is located\n * @param   { String } attrName - either 'ref' or 'data-ref'\n * @param   { String } attrValue - value of the ref attribute\n * @returns { RefExpr } a new RefExpr object\n */\nfunction createRefDirective(dom, tag, attrName, attrValue) {\n  return create(RefExpr).init(dom, tag, attrName, attrValue)\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function (expr) {\n    if (expr.unmount) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n    extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update$$1() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { update.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n  }\n}\n\n/**\n * Create a new if directive\n * @param   { HTMLElement } dom - if root dom node\n * @param   { Tag } context - tag instance where the DOM node is located\n * @param   { String } attr - if expression\n * @returns { IFExpr } a new IfExpr object\n */\nfunction createIfDirective(dom, tag, attr) {\n  return create(IfExpr).init(dom, tag, attr)\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Array } all the expressions found\n */\nfunction parseExpressions(root, mustIncludeRoot) {\n  var this$1 = this;\n\n  var expressions = [];\n\n  walkNodes(root, function (dom) {\n    var type = dom.nodeType;\n    var attr;\n    var tagImpl;\n\n    if (!mustIncludeRoot && dom === root) { return }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { expressions.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return }\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttribute(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      expressions.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n      expressions.push(createIfDirective(dom, this$1, attr));\n      return false\n    }\n\n    if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(attr)) {\n        expressions.push({\n          isRtag: true,\n          expr: attr,\n          dom: dom,\n          attrs: [].slice.call(dom.attributes)\n        });\n\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = get(dom);\n\n    if(isVirtual) {\n      if(getAttribute(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual) { // handled in update\n        if (getAttribute(dom, IS_DIRECTIVE))\n          { warn((\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\")); }\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttribute(dom, 'virtualized', true);\n        var tag = createTag(\n          {tmpl: dom.outerHTML},\n          {root: dom, parent: this$1},\n          dom.innerHTML\n        );\n\n        expressions.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        expressions.push(\n          initChild(\n            tagImpl,\n            {\n              root: dom,\n              parent: this$1\n            },\n            dom.innerHTML,\n            this$1\n          )\n        );\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n      if (!expr) { return }\n      expressions.push(expr);\n    }]);\n  });\n\n  return expressions\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    if (!attr) { return false }\n\n    var name = attr.name;\n    var bool = isBoolAttr(name);\n    var expr;\n\n    if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n      expr =  createRefDirective(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/**\n * Manage the mount state of a tag triggering also the observable events\n * @this Tag\n * @param { Boolean } value - ..of the isMounted flag\n */\nfunction setMountState(value) {\n  var ref = this.__;\n  var isAnonymous = ref.isAnonymous;\n\n  define(this, 'isMounted', value);\n\n  if (!isAnonymous) {\n    if (value) { this.trigger('mount'); }\n    else {\n      this.trigger('unmount');\n      this.off('*');\n      this.__.wasCreated = false;\n    }\n  }\n}\n\n/**\n * Mount the current tag instance\n * @returns { Tag } the current tag instance\n */\nfunction componentMount(tag$$1, dom, expressions, opts) {\n  var __ = tag$$1.__;\n  var root = __.root;\n  root._tag = tag$$1; // keep a reference to the tag just created\n\n  // Read all the attrs on this instance. This give us the info we need for updateOpts\n  parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n    if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = tag$$1; }\n    attr.expr = expr;\n    __.instAttrs.push(attr);\n  }]);\n\n  // update the root adding custom attributes coming from the compiler\n  walkAttributes(__.impl.attrs, function (k, v) { __.implAttrs.push({name: k, value: v}); });\n  parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n    if (expr) { expressions.push(expr); }\n    else { setAttribute(root, attr.name, attr.value); }\n  }]);\n\n  // initialiation\n  updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n  // add global mixins\n  var globalMixin = mixin(GLOBAL_MIXIN);\n\n  if (globalMixin && !__.skipAnonymous) {\n    for (var i in globalMixin) {\n      if (globalMixin.hasOwnProperty(i)) {\n        tag$$1.mixin(globalMixin[i]);\n      }\n    }\n  }\n\n  if (__.impl.fn) { __.impl.fn.call(tag$$1, opts); }\n\n  if (!__.skipAnonymous) { tag$$1.trigger('before-mount'); }\n\n  // parse layout after init. fn may calculate args for nested custom tags\n  each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) { return expressions.push(e); });\n\n  tag$$1.update(__.item);\n\n  if (!__.isAnonymous && !__.isInline) {\n    while (dom.firstChild) { root.appendChild(dom.firstChild); }\n  }\n\n  define(tag$$1, 'root', root);\n\n  // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n  if (!__.skipAnonymous && tag$$1.parent) {\n    var p = getImmediateCustomParent(tag$$1.parent);\n    p.one(!p.isMounted ? 'mount' : 'updated', function () {\n      setMountState.call(tag$$1, true);\n    });\n  } else {\n    // otherwise it's not a child tag we can trigger its mount event\n    setMountState.call(tag$$1, true);\n  }\n\n  tag$$1.__.wasCreated = true;\n\n  return tag$$1\n}\n\n/**\n * Unmount the tag instance\n * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n * @returns { Tag } the current tag instance\n */\nfunction tagUnmount(tag, mustKeepRoot, expressions) {\n  var __ = tag.__;\n  var root = __.root;\n  var tagIndex = __TAGS_CACHE.indexOf(tag);\n  var p = root.parentNode;\n\n  if (!__.skipAnonymous) { tag.trigger('before-unmount'); }\n\n  // clear all attributes coming from the mounted tag\n  walkAttributes(__.impl.attrs, function (name) {\n    if (startsWith(name, ATTRS_PREFIX))\n      { name = name.slice(ATTRS_PREFIX.length); }\n\n    removeAttribute(root, name);\n  });\n\n  // remove all the event listeners\n  tag.__.listeners.forEach(function (dom) {\n    Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n    });\n  });\n\n  // remove tag instance from the global tags cache collection\n  if (tagIndex !== -1) { __TAGS_CACHE.splice(tagIndex, 1); }\n\n  // clean up the parent tags object\n  if (__.parent && !__.isAnonymous) {\n    var ptag = getImmediateCustomParent(__.parent);\n\n    if (__.isVirtual) {\n      Object\n        .keys(tag.tags)\n        .forEach(function (tagName) { return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]); });\n    } else {\n      arrayishRemove(ptag.tags, __.tagName, tag);\n    }\n  }\n\n  // unmount all the virtual directives\n  if (tag.__.virts) {\n    each(tag.__.virts, function (v) {\n      if (v.parentNode) { v.parentNode.removeChild(v); }\n    });\n  }\n\n  // allow expressions to unmount themselves\n  unmountAll(expressions);\n  each(__.instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n  // clear the tag html if it's necessary\n  if (mustKeepRoot) { setInnerHTML(root, ''); }\n  // otherwise detach the root tag from the DOM\n  else if (p) { p.removeChild(root); }\n\n  // custom internal unmount function to avoid relying on the observable\n  if (__.onUnmount) { __.onUnmount(); }\n\n  // weird fix for a weird edge case #2409 and #2436\n  // some users might use your software not as you've expected\n  // so I need to add these dirty hacks to mitigate unexpected issues\n  if (!tag.isMounted) { setMountState.call(tag, true); }\n\n  setMountState.call(tag, false);\n\n  delete root._tag;\n\n  return tag\n}\n\n/**\n * Tag creation factory function\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction createTag(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var tag = conf.context || {};\n  var opts = extend({}, conf.opts);\n  var parent = conf.parent;\n  var isLoop = conf.isLoop;\n  var isAnonymous = !!conf.isAnonymous;\n  var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n  var item = conf.item;\n  // available only for the looped nodes\n  var index = conf.index;\n  // All attributes on the Tag when it's first parsed\n  var instAttrs = [];\n  // expressions on this type of Tag\n  var implAttrs = [];\n  var expressions = [];\n  var root = conf.root;\n  var tagName = conf.tagName || getName(root);\n  var isVirtual = tagName === 'virtual';\n  var isInline = !isVirtual && !impl.tmpl;\n  var dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable(tag); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  define(tag, 'isMounted', false);\n\n  define(tag, '__', {\n    impl: impl,\n    root: root,\n    skipAnonymous: skipAnonymous,\n    implAttrs: implAttrs,\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    isInline: isInline,\n    item: item,\n    parent: parent,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    wasCreated: false,\n    tail: null,\n    head: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  define(tag, '_riot_id', uid()); // base 1 allows test !t._riot_id\n  define(tag, 'root', root);\n  extend(tag, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  define(tag, 'parent', parent || null);\n  define(tag, 'tags', {});\n  define(tag, 'refs', {});\n\n  if (isInline || isLoop && isAnonymous) {\n    dom = root;\n  } else {\n    if (!isVirtual) { root.innerHTML = ''; }\n    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n  }\n\n  define(tag, 'update', function (data) { return componentUpdate(tag, data, expressions); });\n  define(tag, 'mixin', function () {\n    var mixins = [], len = arguments.length;\n    while ( len-- ) mixins[ len ] = arguments[ len ];\n\n    return componentMixin.apply(void 0, [ tag ].concat( mixins ));\n  });\n  define(tag, 'mount', function () { return componentMount(tag, dom, expressions, opts); });\n  define(tag, 'unmount', function (mustKeepRoot) { return tagUnmount(tag, mustKeepRoot, expressions); });\n\n  return tag\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mount$1(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName];\n  var implClass = __TAG_IMPL[tagName].class;\n  var context = ctx || (implClass ? create(implClass.prototype) : {});\n  // cache the inner HTML to fix #855\n  var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n  var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n  var tag;\n\n  if (impl && root) { tag = createTag(impl, conf, innerHTML); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n\n\nvar tags = Object.freeze({\n\tarrayishAdd: arrayishAdd,\n\tgetTagName: getName,\n\tinheritParentProps: inheritParentProps,\n\tmountTo: mount$1,\n\tselectTags: query,\n\tarrayishRemove: arrayishRemove,\n\tgetTag: get,\n\tinitChildTag: initChild,\n\tmoveChildTag: moveChild,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tgetImmediateCustomParentTag: getImmediateCustomParent,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tunmountAll: unmountAll,\n\tcreateIfDirective: createIfDirective,\n\tcreateRefDirective: createRefDirective\n});\n\n/**\n * Riot public api\n */\nvar settings$1 = settings;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$1 = Tag;\nvar tag$1 = tag;\nvar tag2$1 = tag2;\nvar mount$2 = mount;\nvar mixin$1 = mixin;\nvar update$2 = update$1;\nvar unregister$1 = unregister;\nvar version$1 = version;\nvar observable$2 = observable;\n\nvar riot$1 = extend({}, core, {\n  observable: observable,\n  settings: settings$1,\n  util: util,\n})\n\nexports.settings = settings$1;\nexports.util = util;\nexports.Tag = Tag$1;\nexports.tag = tag$1;\nexports.tag2 = tag2$1;\nexports.mount = mount$2;\nexports.mixin = mixin$1;\nexports.update = update$2;\nexports.unregister = unregister$1;\nexports.version = version$1;\nexports.observable = observable$2;\nexports.default = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","riot.tag2(\"su-checkbox\",'<input type=\"checkbox\" checked=\"{checked}\" onclick=\"{click}\" ref=\"target\" disabled=\"{isDisabled()}\" id=\"{getId()}\"> <label if=\"{!opts.label}\" for=\"{getId()}\"><yield></yield></label> <label if=\"{opts.label}\" for=\"{getId()}\">{opts.label}</label>','su-checkbox.ui.checkbox label,[data-is=\"su-checkbox\"].ui.checkbox label{ cursor: pointer; } su-checkbox.ui.read-only input[type=\"checkbox\"],[data-is=\"su-checkbox\"].ui.read-only input[type=\"checkbox\"],su-checkbox.ui.disabled input[type=\"checkbox\"],[data-is=\"su-checkbox\"].ui.disabled input[type=\"checkbox\"]{ cursor: default!important; }','class=\"ui checkbox {opts.class}\"',function(t){\"use strict\";var e=this;this.checked=!1;var i=void 0,a=void 0;this.on(\"mount\",function(){u(),e.checked?t.checked=e.checked:e.checked=c(),i=e.checked,a=e.checked,e.update()}),this.on(\"update\",function(){u(),i!=e.checked?(t.checked=e.checked,i=e.checked,a=e.checked,o()):a!=c()&&(e.checked=c(),i=e.checked,a=e.checked,o())}),this.click=function(){n()||e.isDisabled()?event.preventDefault():(e.checked=!e.checked,o(),e.trigger(\"click\",e.checked))},this.getId=function(){return\"su-checkbox-\"+e._riot_id},this.isDisabled=function(){return e.root.classList.contains(\"disabled\")};var n=function(){return e.root.classList.contains(\"read-only\")},o=function(){e.parent&&e.parent.update()},s=!1,u=function(){void 0!==t.check&&(s||console.warn(\"'check' attribute is deprecated. Please use 'checked'.\"),s=!0,t.checked=t.check,t.check=void 0)},c=function(){return!0===t.checked||\"checked\"===t.checked||\"true\"===t.checked}}),riot.tag2(\"su-datepicker\",'<div class=\"ui {dropdown:opts.popup}\"> <div class=\"ui action input {disabled: isDisabled()}\" if=\"{opts.popup}\"> <input type=\"text\" placeholder=\"{opts.placeholder}\" ref=\"input\" tabindex=\"{getTabindex()}\" readonly=\"{isReadOnly()}\"> <button class=\"ui icon button {disabled: isDisabled()}\" click=\"{toggle}\" onblur=\"{blur}\"> <i class=\"calendar icon\"></i> </button> </div> <div class=\"menu transition {transitionStatus}\" onmousedown=\"{mousedown}\" onmouseup=\"{mouseup}\" onblur=\"{blur}\" tabindex=\"{getTabindex()}\"> <div class=\"ui compact segments\"> <div class=\"ui center aligned secondary segment\"> <div class=\"ui buttons dp-navigation\"> <button class=\"icon tiny ui button {disabled: isDisabled()} prev\" click=\"{clickPrevious}\"> <i class=\"chevron left icon\"></i> </button> <button class=\"ui button {disabled: isDisabled()} month\" click=\"{selectMonth}\">{getCurrentMonthView()}</button> <button class=\"ui button {disabled: isDisabled()} year\" click=\"{selectYear}\">{getCurrentYear()}</button> <button class=\"icon tiny ui button {disabled: isDisabled()} next\" click=\"{clickNext}\"> <i class=\"chevron right icon\"></i> </button> </div> <div class=\"dp-wrapper\"> <div each=\"{week in getWeekNames()}\" class=\"dp-weekday\">{week}</div> </div> </div> <div class=\"ui center aligned segment\" if=\"{!yearSelecting && !monthSelecting}\"> <div each=\"{week in weeks}\" class=\"dp-wrapper\"> <div each=\"{day in week.days}\" class=\"dp-day\"> <button class=\"ui button {today: isToday(day)} {primary: isActive(day)} {non-active: !isActive(day)} {disabled: day.getMonth() != getCurrentMonth() || isDisabled()}\" click=\"{clickDay}\">{day.getDate()}</button> </div> </div> </div> <div class=\"ui center aligned segment\" if=\"{!yearSelecting && !monthSelecting}\"> <div class=\"ui two column grid\"> <div class=\"column dp-clear\"> <button type=\"button\" class=\"ui button {disabled : isDisabled()}\" click=\"{clickClear}\">Clear</button></div> <div class=\"column dp-today\"> <button type=\"button\" class=\"ui button {disabled : isDisabled()}\" click=\"{clickToday}\">Today</button></div> </div> </div> <div class=\"ui center aligned segment\" if=\"{monthSelecting}\"> <div each=\"{element in months}\" class=\"dp-wrapper\"> <div each=\"{month in element}\" class=\"dp-month\"><button class=\"ui button {disabled : isDisabled()}\" click=\"{clickMonth}\">{month.label}</button></div> </div> </div> <div class=\"ui center aligned segment\" if=\"{yearSelecting}\"> <div each=\"{element in years}\" class=\"dp-wrapper\"> <div each=\"{year in element}\" class=\"dp-month\"><button class=\"ui button {disabled : isDisabled()}\" click=\"{clickYear}\">{year}</button></div> </div> </div> </div> </div> </div>','su-datepicker .ui.segment,[data-is=\"su-datepicker\"] .ui.segment{ padding-top: 0.5rem; padding-bottom: 0.5rem; } su-datepicker .ui.buttons.dp-navigation,[data-is=\"su-datepicker\"] .ui.buttons.dp-navigation{ margin-bottom: 0.4rem; } su-datepicker .ui.dropdown,[data-is=\"su-datepicker\"] .ui.dropdown{ display: block; } su-datepicker .dp-wrapper,[data-is=\"su-datepicker\"] .dp-wrapper{ display: flex; } su-datepicker .dp-day,[data-is=\"su-datepicker\"] .dp-day,su-datepicker .dp-month,[data-is=\"su-datepicker\"] .dp-month{ cursor: pointer; } su-datepicker .dp-weekday,[data-is=\"su-datepicker\"] .dp-weekday,su-datepicker .dp-day,[data-is=\"su-datepicker\"] .dp-day,su-datepicker .dp-day .ui.button,[data-is=\"su-datepicker\"] .dp-day .ui.button{ width: 2.5rem; } su-datepicker .dp-month,[data-is=\"su-datepicker\"] .dp-month,su-datepicker .dp-month .ui.button,[data-is=\"su-datepicker\"] .dp-month .ui.button{ width: 4.375rem; } su-datepicker .dp-day .ui.button,[data-is=\"su-datepicker\"] .dp-day .ui.button,su-datepicker .dp-month .ui.button,[data-is=\"su-datepicker\"] .dp-month .ui.button{ padding: 0; height: 2.5rem; font-weight: normal } su-datepicker .dp-day .ui.button.today,[data-is=\"su-datepicker\"] .dp-day .ui.button.today{ font-weight: 700; } su-datepicker .dp-navigation .ui.button,[data-is=\"su-datepicker\"] .dp-navigation .ui.button,su-datepicker .dp-month .ui.button,[data-is=\"su-datepicker\"] .dp-month .ui.button,su-datepicker .dp-day .ui.button.non-active,[data-is=\"su-datepicker\"] .dp-day .ui.button.non-active{ background-color: transparent; } su-datepicker .dp-navigation .ui.button:hover,[data-is=\"su-datepicker\"] .dp-navigation .ui.button:hover,su-datepicker .dp-month .ui.button:hover,[data-is=\"su-datepicker\"] .dp-month .ui.button:hover,su-datepicker .dp-day .ui.button.non-active:hover,[data-is=\"su-datepicker\"] .dp-day .ui.button.non-active:hover{ background-color: #e0e1e2; } su-datepicker .dp-day .ui.button.disabled,[data-is=\"su-datepicker\"] .dp-day .ui.button.disabled{ pointer-events: all !important; } su-datepicker .dp-navigation,[data-is=\"su-datepicker\"] .dp-navigation{ width: 100%; } su-datepicker .dp-navigation .ui.button,[data-is=\"su-datepicker\"] .dp-navigation .ui.button{ width: 20%; } su-datepicker .dp-navigation .ui.button.year,[data-is=\"su-datepicker\"] .dp-navigation .ui.button.year,su-datepicker .dp-navigation .ui.button.month,[data-is=\"su-datepicker\"] .dp-navigation .ui.button.month{ width: 30%; }',\"\",function(s){\"use strict\";var u=this;this.weeks=[],this.value=null,this.transitionStatus=s.popup?\"hidden\":\"visible\";var t=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],e=[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],i=!1,a=!1,n=null,o=null,c=null;this.on(\"mount\",function(){void 0===s.riotValue&&void 0!==s.value&&(s.riotValue=s.value),u.value||(u.value=y(s.riotValue)),n=y(u.value),o=y(s.riotValue),u.value&&(s.currentDate=y(u.value)),s.currentDate||(s.currentDate=new Date),u.months=h(),u.update()}),this.on(\"update\",function(){var t=!1;k(n,u.value)?k(o,s.riotValue)||(u.value=y(s.riotValue),o=y(s.riotValue),n=y(s.riotValue),t=!0):(n=y(u.value),t=!0),t&&u.value&&(s.currentDate=y(u.value)),k(c,s.currentDate)||(c=y(s.currentDate),r())}),this.selectMonth=function(){u.yearSelecting=!1,u.monthSelecting=!u.monthSelecting},this.selectYear=function(){u.years=p(),u.monthSelecting=!1,u.yearSelecting=!u.yearSelecting},this.clickDay=function(t){u.isReadOnly()||u.isDisabled()||(v(t.item.day),u.trigger(\"click\",u.value))},this.clickMonth=function(t){s.currentDate.setMonth(t.item.month.value),u.monthSelecting=!1},this.clickYear=function(t){s.currentDate.setYear(t.item.year),u.selectMonth()},this.clickPrevious=function(){u.yearSelecting?l(-20):(u.monthSelecting=!1,d(s.currentDate,-1))},this.clickNext=function(){u.yearSelecting?l(20):(u.monthSelecting=!1,d(s.currentDate,1))},this.clickClear=function(){v(null),u.trigger(\"clear\",u.value)},this.clickToday=function(){v(new Date),u.trigger(\"today\",u.value)},this.toggle=function(){u.isReadOnly()||u.isDisabled()||(i?f():m())},this.mousedown=function(){a=!0},this.mouseup=function(){a=!1},this.blur=function(){s.popup&&!a&&f()};var r=function(){var t=s.currentDate.getFullYear(),e=s.currentDate.getMonth(),i=1-new Date(t,e,1).getDay();u.weeks=[];for(var a=0;a<6;a++){for(var n=[],o=0;o<7;o++)n.push(new Date(t,e,i++));u.weeks.push({days:n})}},l=function(e){u.years=u.years.map(function(t){return t=t.map(function(t){return t+e})})},d=function(t,e){t.setMonth(t.getMonth()+e)},p=function(){for(var t=[[],[],[],[],[]],e=0;e<20;e++)t[(e-e%4)/4][e%4]=s.currentDate.getFullYear()+e-9;return t},h=function(){var i=[[],[],[]];return t.forEach(function(t,e){i[(e-e%4)/4][e%4]={label:t,value:e}}),i},m=function(){u.transitionStatus=\"visible\",i=!0,u.value&&(s.currentDate=y(u.value)),s.currentDate||(s.currentDate=new Date),u.trigger(\"open\",u.value)},f=function(){u.transitionStatus=\"hidden\",i=!1,u.trigger(\"close\",u.value)},v=function(t){u.value=t,u.refs.input&&(u.refs.input.value=u.value?g(u.value,s.pattern):null,f()),u.trigger(\"change\",u.value)},g=function(t,e){return e||(e=\"yyyy-MM-dd\"),e=(e=(e=(e=(e=(e=e.replace(/yyyy/g,t.getFullYear().toString())).replace(/yy/g,t.getFullYear().toString().slice(-2))).replace(/MM/g,b(t.getMonth()+1,2))).replace(/M/g,(t.getMonth()+1).toString())).replace(/dd/g,b(t.getDate(),2))).replace(/d/g,t.getDate().toString())},b=function(t,e){var i=t.toString();return i.length>=e?i:new Array(e-i.length+1).join(\"0\")+i},k=function(t,e){return t==e||void 0!==t&&void 0!==e&&null!==t&&null!==e&&(t.getFullYear()===e.getFullYear()&&t.getMonth()===e.getMonth()&&t.getDate()===e.getDate())},y=function(t){return t?new Date(t.getTime()):t};this.getCurrentYear=function(){if(s.currentDate)return s.currentDate.getFullYear()},this.getCurrentMonthView=function(){if(s.currentDate)return\"\"+t[s.currentDate.getMonth()]},this.getCurrentMonth=function(){return s.currentDate.getMonth()},this.getWeekNames=function(){return e},this.isActive=function(t){return k(u.value,t)},this.isToday=function(t){return k(t,new Date)},this.getTabindex=function(){return!!s.popup&&(s.tabindex?s.tabindex:0)},this.isReadOnly=function(){return u.root.classList.contains(\"read-only\")},this.isDisabled=function(){return u.root.classList.contains(\"disabled\")}}),riot.tag2(\"su-dropdown\",'<i class=\"dropdown icon\"></i> <input class=\"search\" autocomplete=\"off\" tabindex=\"{getTabindex()}\" ref=\"condition\" if=\"{opts.search}\" oninput=\"{input}\" onclick=\"{clickSearch}\" onfocus=\"{focus}\" onblur=\"{blur}\" readonly=\"{isReadOnly()}\"> <a each=\"{item in opts.items}\" class=\"ui label transition visible\" style=\"display: inline-block !important;\" if=\"{item.selected}\"> {item.label} <i class=\"delete icon\" onclick=\"{unselect}\"></i> </a> <div class=\"{default: default} text {filtered: filtered}\" if=\"{!opts.multiple || !selectedFlg}\"> {label} </div> <div class=\"menu transition {transitionStatus}\" onmousedown=\"{mousedown}\" onmouseup=\"{mouseup}\" onblur=\"{blur}\" tabindex=\"-1\"> <div each=\"{item in opts.items}\" riot-value=\"{item.value}\" default=\"{item.default}\" onmousedown=\"{mousedown}\" onmouseup=\"{mouseup}\" class=\"{item: isItem(item)} {header: item.header && !filtered} {divider: item.divider && !filtered} {default: item.default} {active: item.active} {selected: item.active}\" onclick=\"{itemClick}\"> <i class=\"{item.icon} icon\" if=\"{item.icon}\"></i> <img class=\"ui avatar image\" riot-src=\"{item.image}\" if=\"{item.image}\"> <span class=\"description\" if=\"{item.description}\">{item.description}</span> <span class=\"text\">{item.label}</span> </div> <div class=\"message\" if=\"{filtered && filteredItems.length == 0}\">No results found.</div> </div>','su-dropdown.ui.dropdown .menu>.item.default,[data-is=\"su-dropdown\"].ui.dropdown .menu>.item.default{ color: rgba(0, 0, 0, 0.4) }','class=\"ui selection {opts.class} {search: opts.search} {multiple: opts.multiple} dropdown {active: isActive()} {visible: isActive()}\" onclick=\"{toggle}\" onfocus=\"{focus}\" onblur=\"{blur}\" onkeydown=\"{keydown}\" onkeyup=\"{keyup}\" tabindex=\"{opts.search ? -1 : getTabindex()}\"',function(s){\"use strict\";var u=this;this.selectedFlg=!1,this.filtered=!1,this.transitionStatus=\"hidden\",this.value=\"\",this.label=\"\";var t=!1,n=13,c=27,r=38,l=40;s.items&&0<s.items.length&&(this.label=s.items[0].label,this.value=s.items[0].value,this.default=s.items[0].default),this.on(\"update\",function(){if(s.multiple)s.items.forEach(function(t){return t.selected=!1}),s.items.filter(function(t){return u.value&&0<=u.value.indexOf(t.value)}).forEach(function(t){return t.selected=!0}),h(!0);else if(s.items){var t=s.items.filter(function(t){return t.value===u.value});if(t&&0<t.length){var e=t[0];u.label!==e.label&&o(e,!0)}else s.items&&0<s.items.length&&(u.value!=s.items[0].value&&(u.value=s.items[0].value),u.label!=s.items[0].label&&(u.label=s.items[0].label,u.default=s.items[0].default))}}),this.toggle=function(){t?p():d()},this.focus=function(){d()},this.mousedown=function(){u.itemActivated=!0},this.mouseup=function(){u.itemActivated=!1},this.blur=function(){u.itemActivated||p()},this.itemClick=function(t){if(t.stopPropagation(),u.isItem(t.item.item)){if(s.multiple)return t.item.item.default||(t.item.item.selected=!0),void h();o(t.item.item),p()}},this.keydown=function(t){var e=t.keyCode;if(e==c&&p(),e==l&&d(),e!=r&&e!=l)return!0;t.preventDefault();var i=s.items.filter(function(t){return!(s.search&&!t.searched)&&(!s.multiple||!t.default&&!t.selected)});if(0==i.length)return!0;if(i.every(function(t){return!t.active}))return i[0].active=!0;var a=parseInt(i.map(function(t,e){return t.active?e:-1}).filter(function(t){return 0<=t}));if(e==r){var n=i.filter(function(t,e){return e<a&&!t.header&&!t.divider});0<n.length&&(i[a].active=!1,n[n.length-1].active=!0)}else if(e==l){var o=i.filter(function(t,e){return a<e&&!t.header&&!t.divider});0<o.length&&(i[a].active=!1,o[0].active=!0)}u.update(),m()},this.keyup=function(t){if(t.keyCode==n){var e=s.items.filter(function(t){return t.searched&&!t.selected}),i=parseInt(e.map(function(t,e){return t.active?e:-1}).filter(function(t){return 0<=t})),a=e[i];a&&(s.multiple?(a.selected=!0,a.active=!1,i<e.length-1?e[i+1].active=!0:0<i&&(e[i-1].active=!0),h()):(a.active=!1,o(a),p()))}},this.clickSearch=function(t){t.stopPropagation()},this.input=function(t){var e=t.target.value.toLowerCase();u.filtered=0<e.length,i(e)},this.unselect=function(t){t.stopPropagation(),t.item.item.selected=!1,u.value=s.items.filter(function(t){return t.selected}).map(function(t){return t.value}),u.selectedFlg=s.items.some(function(t){return t.selected}),a()};var d=function(){u.openning||u.closing||t||u.isReadOnly()||u.isDisabled()||(u.openning=!0,i(\"\"),u.transitionStatus=\"visible animating in slide down\",s.items.forEach(function(t){return t.active=!1}),setTimeout(function(){u.openning=!1,t=!0,u.transitionStatus=\"visible\",u.update()},300),s.search&&u.refs.condition.focus(),u.update(),m(),u.trigger(\"open\"))},p=function(){!u.closing&&t&&(u.closing=!0,u.transitionStatus=\"visible animating out slide down\",setTimeout(function(){u.closing=!1,t=!1,u.transitionStatus=\"hidden\",u.update()},300),s.search&&(u.refs.condition.blur(),u.filtered&&0<u.filteredItems.length?o(u.filteredItems[0]):(u.refs.condition.value=\"\",u.filtered=!1)),u.update(),u.trigger(\"close\"))},o=function(t,e){u.value!==t.value||u.label!==t.label||u.default!==t.default?(u.value=t.value,u.label=t.label,u.default=t.default,s.search&&(u.refs.condition.value=\"\",u.filtered=!1),e||(u.update(),a(),u.trigger(\"select\",t),u.trigger(\"change\",t))):e||u.trigger(\"select\",t)},h=function(t){JSON.stringify(u.value)!=JSON.stringify(s.items.filter(function(t){return t.selected}).map(function(t){return t.value}))||u.selectedFlg!=s.items.some(function(t){return t.selected})?(u.value=s.items.filter(function(t){return t.selected}).map(function(t){return t.value}),u.selectedFlg=s.items.some(function(t){return t.selected}),t||(u.update(),a(),u.trigger(\"select\",s.items.filter(function(t){return t.selected})),u.trigger(\"change\",s.items.filter(function(t){return t.selected})))):t||u.trigger(\"select\",s.items.filter(function(t){return t.selected}))},i=function(e){s.items.forEach(function(t){t.searched=t.label&&0<=t.label.toLowerCase().indexOf(e)}),u.filteredItems=s.items.filter(function(t){return t.searched}),u.update(),u.trigger(\"search\")},m=function(){var t=u.root.querySelector(\".menu\"),e=u.root.querySelector(\".item.active\");if(t&&e){var i=t.scrollTop,a=e.offsetTop,n=parseInt(document.defaultView.getComputedStyle(e,null).height.replace(\"px\",\"\")),o=parseInt(document.defaultView.getComputedStyle(t,null).height.replace(\"px\",\"\"));(a<i||i+o<a+n)&&(t.scrollTop=a)}},a=function(){u.parent&&u.parent.update()};this.isItem=function(t){return(!s.multiple||!t.default&&!t.selected)&&(t.searched&&!t.header&&!t.divider)},this.isActive=function(){return!u.closing&&(u.openning||t)},this.getTabindex=function(){return s.tabindex?s.tabindex:0},this.isReadOnly=function(){return u.root.classList.contains(\"read-only\")},this.isDisabled=function(){return u.root.classList.contains(\"disabled\")}}),riot.tag2(\"su-modal\",'<div class=\"ui modal transition visible active {opts.class}\" onclick=\"{clickModal}\" id=\"{getId()}\"> <i class=\"close icon\" if=\"{isFullscreen()}\" onclick=\"{hide}\"></i> <div class=\"ui header {icon: opts.modal.header.icon}\" if=\"{opts.modal.header}\"> <i class=\"icon {opts.modal.header.icon}\" if=\"{opts.modal.header.icon}\"></i> {(opts.modal.header.text) ? opts.modal.header.text : opts.modal.header} </div> <div class=\"content {image: isImageContent()}\" ref=\"content\"> <yield></yield> </div> <div class=\"actions\"> <div each=\"{opts.modal.buttons}\" class=\"ui button {type} {labeled: icon && text} {icon: icon} {inverted: isBasic()} {disabled: disabled}\" onclick=\"{parent.click}\"> {text} <i class=\"icon {icon}\" if=\"{icon}\"></i> </div> </div> </div>','su-modal.ui.dimmer.visible.transition,[data-is=\"su-modal\"].ui.dimmer.visible.transition{ display: flex !important; align-items: center; justify-content: center; } su-modal .ui.modal,[data-is=\"su-modal\"] .ui.modal{ top: auto; left: auto; position: relative; margin: 0 !important; } su-modal .ui.fullscreen.modal,[data-is=\"su-modal\"] .ui.fullscreen.modal{ left: 0!important; }','class=\"ui dimmer modals page transition {transitionStatus}\" onclick=\"{dimmerClose}\"',function(t){\"use strict\";var i=this,e=!1,a=void 0,n=void 0,o=void 0;t.modal||(t.modal={}),this.on(\"mount\",function(){void 0===t.modal.closable&&(t.modal.closable=!0)}),this.on(\"update\",function(){0<i.refs.content.getElementsByTagName(\"img\").length&&(e=!0)}),this.show=function(){a||n||o||(a=!0,i.transitionStatus=\"animating fade in visible\",i.update(),i.trigger(\"show\"),setTimeout(function(){a=!1,o=!0,i.transitionStatus=\"visible active\",i.update()},500))},this.click=function(t){i.trigger(t.item.action||t.item.text),(void 0===t.item.closable||t.item.closable)&&i.hide()},this.dimmerClose=function(){t.modal.closable&&!i.isBasic()&&i.hide()},this.clickModal=function(t){t.stopPropagation()},this.hide=function(){a||n||!o||(n=!0,i.transitionStatus=\"animating fade out visible active\",i.update(),i.trigger(\"hide\"),setTimeout(function(){o=n=!1,i.transitionStatus=\"\",i.update()},300))};var s=function(t){var e=document.getElementById(i.getId());return!!e&&e.classList.contains(t)};this.getId=function(){return\"su-modal-\"+i._riot_id},this.isFullscreen=function(){return s(\"fullscreen\")},this.isBasic=function(){return s(\"basic\")},this.isImageContent=function(){return e}}),riot.tag2(\"su-popup\",'<div id=\"{getId()}\" class=\"ui popup {opts.position} {opts.dataVariation} transition {transitionStatus} {nowrap: isNowrap()}\"></div> <yield></yield>','su-popup,[data-is=\"su-popup\"]{ position: relative; } su-popup .ui.popup,[data-is=\"su-popup\"] .ui.popup{ position: absolute; } su-popup .ui.popup.nowrap,[data-is=\"su-popup\"] .ui.popup.nowrap{ white-space: nowrap; } su-popup .ui.popup.wide,[data-is=\"su-popup\"] .ui.popup.wide{ width: 350px; } su-popup .ui.popup.very.wide,[data-is=\"su-popup\"] .ui.popup.very.wide{ width: 550px; } su-popup .ui.popup.top.left,[data-is=\"su-popup\"] .ui.popup.top.left{ top: auto; bottom: 100%; left: 1em; right: auto; margin-left: -1rem; } su-popup .ui.popup.bottom.left,[data-is=\"su-popup\"] .ui.popup.bottom.left{ top: 100%; bottom: auto; left: 1em; right: auto; margin-left: -1rem; } su-popup .ui.popup.top.center,[data-is=\"su-popup\"] .ui.popup.top.center{ top: auto; bottom: 100%; left: 50%; right: auto; -webkit-transform: translateX(-50%) !important; transform: translateX(-50%) !important; } su-popup .ui.popup.bottom.center,[data-is=\"su-popup\"] .ui.popup.bottom.center{ top: 100%; bottom: auto; left: 50%; right: auto; -webkit-transform: translateX(-50%) !important; transform: translateX(-50%) !important; } su-popup .ui.popup.top.right,[data-is=\"su-popup\"] .ui.popup.top.right{ top: auto; bottom: 100%; left: auto; right: 1em; margin-right: -1rem; } su-popup .ui.popup.bottom.right,[data-is=\"su-popup\"] .ui.popup.bottom.right{ top: 100%; bottom: auto; left: auto; right: 1em; margin-right: -1rem; } su-popup .ui.popup.left.center,[data-is=\"su-popup\"] .ui.popup.left.center{ left: auto; right: 100%; top: 50%; -webkit-transform: translateY(-50%) !important; transform: translateY(-50%) !important; } su-popup .ui.popup.right.center,[data-is=\"su-popup\"] .ui.popup.right.center{ left: 100%; right: auto; top: 50%; -webkit-transform: translateY(-50%) !important; transform: translateY(-50%) !important; }','onmouseover=\"{mouseover}\" onmouseout=\"{mouseout}\"',function(t){\"use strict\";var e=this;this.content=\"\",this.on(\"mount\",function(){t.position||(t.position=\"top left\"),t.tooltip?t.dataTitle?e.content='<div class=\"header\">'+t.dataTitle+'</div><div class=\"content\">'+t.tooltip+\"</div>\":e.content=t.tooltip:e.tags[\"su-popup-content\"]&&(e.content=e.tags[\"su-popup-content\"].root.innerHTML,e.tags[\"su-popup-content\"].unmount()),document.getElementById(e.getId()).innerHTML=e.content,e.update()}),this.mouseover=function(){e.transitionStatus=\"visible\",e.trigger(\"mouseover\")},this.mouseout=function(){e.transitionStatus=\"hidden\",e.trigger(\"mouseout\")},this.isNowrap=function(){return!(t.dataVariation&&0<=t.dataVariation.indexOf(\"wide\"))},this.getId=function(){return\"su-popup-\"+e._riot_id}}),riot.tag2(\"su-popup-content\",\"\",\"\",\"\",function(t){}),riot.tag2(\"su-radio\",'<input type=\"radio\" name=\"{name}\" riot-value=\"{value}\" checked=\"{checked}\" onclick=\"{click}\" ref=\"target\" id=\"{getId()}\"> <label if=\"{!opts.label}\" for=\"{getId()}\"><yield></yield></label> <label if=\"{opts.label}\" for=\"{getId()}\">{opts.label}</label>','su-radio.ui.checkbox label,[data-is=\"su-radio\"].ui.checkbox label{ cursor: pointer; } su-radio.ui.read-only input[type=\"radio\"],[data-is=\"su-radio\"].ui.read-only input[type=\"radio\"],su-radio.ui.disabled input[type=\"radio\"],[data-is=\"su-radio\"].ui.disabled input[type=\"radio\"]{ cursor: default!important; }','class=\"ui {radio: isRadio()} checkbox {opts.class}\"',function(t){\"use strict\";var e=this;this.name=\"\",this.checked=!1;var i=void 0,a=void 0;this.on(\"mount\",function(){e.checked?t.checked=e.checked:e.checked=!0===t.checked||\"checked\"===t.checked||\"true\"===t.checked,i=e.checked,a=t.checked,e.update()}),this.on(\"update\",function(){e.name=t.name,e.value=t.value,i!=e.checked?(t.checked=e.checked,i=e.checked):a!=t.checked&&(e.checked=t.checked,a=t.checked)}),this.click=function(t){n()||e.isDisabled()?t.preventDefault():(e.checked=t.target.checked,e.trigger(\"click\",t.target.value))};var n=function(){return e.root.classList.contains(\"read-only\")};this.getId=function(){return\"su-radio-\"+e._riot_id},this.isDisabled=function(){return e.root.classList.contains(\"disabled\")},this.isRadio=function(){return!e.root.classList.contains(\"slider\")}}),riot.tag2(\"su-radio-group\",\"<yield></yield>\",\"\",\"\",function(i){\"use strict\";var a=this;this.label=\"\",this.value=\"\";var n=void 0,o=void 0;this.on(\"mount\",function(){void 0===i.riotValue&&void 0!==i.value&&(i.riotValue=i.value),a.value?i.riotValue=a.value:a.value=i.riotValue,n=a.value,o=a.value;var t=a.tags[\"su-radio\"];Array.isArray(t)||(t=[t]),t.forEach(function(t){e(t)}),a.update()}),this.on(\"update\",function(){var t=!1;n!=a.value?(i.riotValue=a.value,o=a.value,n=a.value,t=!0):o!=i.riotValue&&(a.value=i.riotValue,o=i.riotValue,n=i.riotValue,t=!0);var e=a.tags[\"su-radio\"];Array.isArray(e)||(e=[e]),e.forEach(function(t){s(t)}),t&&a.trigger(\"change\",a.value)});var s=function(t){void 0!==t.opts.value&&(t.checked=a.value==t.opts.value,t.checked&&(a.label=t.root.getElementsByTagName(\"label\")[0].innerText))},e=function(t){t.opts.name=u(),t.on(\"click\",function(t){a.value=t,a.update()})},u=function(){return\"su-radio-name-\"+a._riot_id}}),riot.tag2(\"su-tab\",\"<yield></yield>\",'su-tab.ui.segment,[data-is=\"su-tab\"].ui.segment{ margin-top: 0; margin-bottom: 0; } su-tab.ui.segment.top.attached,[data-is=\"su-tab\"].ui.segment.top.attached{ margin-top: 0 } su-tab.ui.segment.bottom.attached,[data-is=\"su-tab\"].ui.segment.bottom.attached{ margin-bottom: 0 }','class=\"ui {opts.class} {active: active} tab\"',function(t){\"use strict\";this.active=!1}),riot.tag2(\"su-tab-header\",\"<yield></yield>\",\"\",'class=\"ui {opts.class} menu\"',function(t){}),riot.tag2(\"su-tab-title\",'<a class=\"{opts.class} {active: active} item\" onclick=\"{click}\"> <yield></yield> </a>',\"\",\"\",function(t){\"use strict\";var i=this;this.active=!1;var a=0,e=void 0;this.on(\"mount\",function(){e=i.parent.tags[\"su-tab-title\"],Array.isArray(e)||(e=[e]),e.forEach(function(t,e){t._riot_id==i._riot_id&&(a=e)})}),this.click=function(){e.forEach(function(t){t.active=!1}),i.parent.parent.click(a),e[a].active=!0,i.update(),i.trigger(\"click\",i.parent.parent.tabs[a])}}),riot.tag2(\"su-tabset\",'<div class=\"ui {opts.class} {getClass()} menu\" if=\"{!isBottom() && !hasTitle()}\"> <a each=\"{tab, i in tabs}\" class=\"{tab.opts.titleClass} {active: tab.active} item\" onclick=\"{click.bind(this, i)}\">{tab.opts.title}</a> </div> <yield></yield> <div class=\"ui {opts.class} {getClass()} menu\" if=\"{isBottom() && !hasTitle()}\"> <a each=\"{tab, i in tabs}\" class=\"{tab.opts.titleClass} {active: tab.active} item\" onclick=\"{click.bind(this, i)}\">{tab.opts.title}</a> </div>',\"\",\"\",function(t){\"use strict\";var i=this;this.tabs=[],this.on(\"mount\",function(){i.tags[\"su-tab-header\"]&&(i.tags[\"su-tab-header\"].opts.class=n()),i.tabs=i.tags[\"su-tab\"],Array.isArray(i.tabs)||(i.tabs=[i.tabs]);var e=!1;if(i.tabs.forEach(function(t){a(t),t.opts.active&&(e=!0,t.active=!0)}),!e){var t=i.hasTitle();t&&(t[0].active=!0),i.tabs[0].active=!0}i.update()}),this.click=function(t){i.tabs.forEach(function(t){t.active=!1}),i.tabs[t].active=!0,i.update(),i.trigger(\"click\",i.tabs[t])},this.isBottom=function(){return o(\"bottom\")},this.hasTitle=function(){if(!i.tags[\"su-tab-header\"])return!1;var t=i.tags[\"su-tab-header\"].tags[\"su-tab-title\"];return!!t&&(Array.isArray(t)?t:[t])},this.getClass=function(){if(o(\"tabular\")&&!o(\"attached\"))return\"attached\"};var a=function(t){if(!t.opts.class){var e=[\"segment\"];o(\"tabular\")&&e.push(\"tabular\"),!o(\"attached\")&&!o(\"tabular\")||o(\"left\")||o(\"right\")||(o(\"bottom\")?e.push(\"top\"):e.push(\"bottom\"),e.push(\"attached\")),t.opts.class=e.join(\" \")}},n=function(){var t=[];return(o(\"left\")||o(\"right\"))&&(t.push(\"vertical\"),t.push(\"fluid\")),o(\"left\")&&t.push(\"left\"),o(\"right\")&&t.push(\"right\"),o(\"tabular\")&&t.push(\"tabular\"),t.join(\" \")},o=function(t){return i.root.classList.contains(t)}});","import riot from 'riot'\nimport route from 'riot-route'\nimport 'semantic-ui-riot/dist/semantic-ui-riot.min.js'\n\nimport '../tags/introduction.tag'\n// import '../tags/navigation.tag'\n// import '../tags/demo-checkbox.tag'\n// import '../tags/demo-datepicker.tag'\n// import '../tags/demo-dropdown.tag' // slowly\n// import '../tags/demo-modal.tag'\n// import '../tags/demo-popup.tag'\n// import '../tags/demo-radio.tag'\n// import '../tags/demo-tab.tag'\n\nroute('', () => {\n  riot.mount('content', 'root')\n})\n\nroute(collection => {\n  riot.mount('content', collection)\n})\n\nroute.start(true)\n\nriot.mount('*')\n\nriot.mixin({\n  init: function () {\n    this.on('mount', () => {\n      PR.prettyPrint(false)\n    })\n  },\n\n  toggleExample: event => {\n    const childs = event.target.parentElement.parentElement.childNodes\n    const segments = Array.from(childs).filter(element => element.classList && element.classList.contains('segment'))\n    if (segments[2].classList.contains('hidden')) {\n      segments[1].classList.remove('bottom')\n      segments[2].classList.remove('hidden')\n    } else {\n      segments[1].classList.remove('attached')\n      segments[1].classList.add('bottom')\n      segments[1].classList.add('attached')\n      segments[2].classList.add('hidden')\n    }\n  }\n})","<root>\n  <h1 class=\"ui header\">\n    Semantic UI Riot\n    <div class=\"sub header\">Semantic-UI-Riot integration.</div>\n  </h1>\n  <h2 class=\"ui dividing header\" id=\"introduction\">Introduction</h2>\n  <p>\n    Semantic UI Riot is Riot integration for <a href=\"https://semantic-ui.com/\">Semantic UI</a>.\n  </p>\n</root>"],"sourceRoot":""}